var Aria = require("../Aria");
var ariaUtilsMath = require("./Math");
var ariaUtilsType = require("./Type");
var ariaCoreBrowser = require("../core/Browser");


/**
 * Handles sizes measurements and application for DOM elements
 * @class aria.utils.Size
 * @extends aria.core.JsObject
 * @singleton
 */
module.exports = Aria.classDefinition({
    $classpath : 'aria.utils.Size',
    $singleton : true,
    $prototype : {

        /**
         * Get size of a DOM element
         * @param {HTMLElement} element
         * @return {Object} width and height
         */
        getSize : function (element) {
            return {
                width : element.offsetWidth,
                height : element.offsetHeight
            };
        },

        /**
         * Create a simple hidden DIV to be used by functions requiring to compute sizes for hidden elements
         * @return {HTMLElement}
         * @private
         */
        __createDomContainer : function () {
            var document = Aria.$window.document;
            var domContainer = document.createElement("div");
            domContainer.style.cssText = "position:absolute;top:0px;left:0px;visibility:hidden;display:block;width:0px;height:0px;";
            return document.body.appendChild(domContainer);
        },

        /**
         * Measure the size of an element without constrains
         * @param {HTMLElement} element
         * @return {Object} JSON object like { height : {Number}, width : {Number} }
         */
        getFreeSize : function (element) {
            // Note: as of 8/02/2012, getFreeSize doesn't seem to be used in the framework
            var domContainer = this.__createDomContainer();
            var parentNode = element.parentNode;
            domContainer.appendChild(element);

            var width = element.offsetWidth;
            var height = element.offsetHeight;

            var size = /** @type aria.utils.DomBeans:Size */
            {
                'width' : width,
                'height' : height
            };

            if (ariaUtilsType.isHTMLElement(parentNode)) {
                parentNode.appendChild(element);
            }

            // remove dom container:
            domContainer.parentNode.removeChild(domContainer);

            return size;
        },

        /**
         * Set the size of a given DOM element with contrains (min and max)
         * @param {HTMLElement} element
         * @param {Object} widthConf
         *
         * <pre>
         * {
         *     min : Integer
         *     max : Integer
         * }
         * </pre>
         *
         * @param {Object} heightConf
         *
         * <pre>
         * {
         *     min : Integer
         *     max : Integer
         * }
         * </pre>
         *
         * @return {Object} new width and height if one of them have changed
         */
        setContrains : function (element, widthConf, heightConf) {
            // PROFILING // var profilingId = this.$startMeasure("setContrains");
            var measured, newValue, result = {}, changedWidth = false, changedHeight = false;
            var changedOverflowY = false;
            var savedScrollBarY = element.style.overflowY;

            // for width
            if (widthConf) {
                measured = element.offsetWidth;
                newValue = ariaUtilsMath.normalize(measured, widthConf.min, widthConf.max);
                if (newValue != measured) {
                    element.style.width = newValue + "px";
                    changedWidth = true;
                }
                result.width = newValue;
            }

            // for height
            if (heightConf) {
                measured = element.offsetHeight;
                newValue = ariaUtilsMath.normalize(measured, heightConf.min, heightConf.max);
                if (newValue != measured) {
                    element.style.height = newValue + "px";
                    changedHeight = true;
                    changedOverflowY = (newValue < measured);
                    if (changedOverflowY) {
                        element.style.overflowY = "scroll";
                        if ((ariaCoreBrowser.isOldIE && ariaCoreBrowser.majorVersion < 8) || (ariaCoreBrowser.isMac)) {
                            var scrollbarSize = aria.templates.Layout.getScrollbarsWidth();
                            element.style['paddingRight'] = element.style['paddingRight'] === '' ? scrollbarSize + 'px' : (parseInt(element.style['paddingRight'], 10) + scrollbarSize) + "px";
                        }
                        // recalculate the width
                        var newWidth = ariaUtilsMath.normalize(element.offsetWidth, widthConf.min, widthConf.max);
                        element.style.width = newWidth + "px";
                        changedWidth = true;
                        result.width = newWidth;
                    }
                }
                result.height = newValue;
            }

            if (changedWidth || changedHeight) {
                // update missing value
                if (!widthConf) {
                    result.width = element.offsetWidth;
                }
                if (!heightConf) {
                    result.height = element.offsetHeight;
                }

                if (changedOverflowY) {
                    element.style.overflowY = savedScrollBarY;
                    if ((ariaCoreBrowser.isOldIE && ariaCoreBrowser.majorVersion < 8)  || (ariaCoreBrowser.isMac)) {
                        var scrollbarSize = aria.templates.Layout.getScrollbarsWidth();
                        element.style['paddingRight'] = (parseInt(element.style['paddingRight'], 10) - scrollbarSize) + "px";
                    }
                }
                // PROFILING // this.$stopMeasure(profilingId);
                return result;
            }
            // PROFILING // this.$stopMeasure(profilingId);
            return null;
        }
    }
});
